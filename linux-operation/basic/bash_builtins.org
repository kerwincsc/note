
* BASH内建工具

** bg|fg|jobs

*** bg

    #+BEGIN_QUOTE
    bg [ _jobsepc_ ...]
    #+END_QUOTE

    在后台恢复运行每一个被暂停的作业 _jobsepc_ 的运行, 就好像它被用 =&= 启动了一样.

    如果 _jobspec_ 未指定, 将会按shell意见使用最近的作业.

    bg _jobspec_ 返回零, 除非运行时作业控制是禁止的, 或者运行时作业控制是允许的, 但是被指定的 _jobspec_ 一个都没有找到, 或者没有以作业控制启动.

*** fg

    #+BEGIN_QUOTE
    fg [ _jobspec_ ]
    #+END_QUOTE

    恢复 _jobspec_ 到前台, 并且使它成为当前作业. 如果 _jobspec_ 未指定, 将会按shell意见使用最近的作业.

    返回值有以下几种情况: 

    1. 放到前台执行的命令的返回值;

    2. 将返回失败:

       - 作业控制被关闭时运行;

       - 作业控制被打开时运行, 倘若 _jobspec_ 没有指定一个合法作业或者 _jobsepc_ 指定了一个没有以作业控制启动的作业;

*** jobs

    #+BEGIN_QUOTE
    jobs [-lnprs] [ _jobspec_ ... ]

    jobs -x command [ _args_ ... ]
    #+END_QUOTE

    第一种形式列出了活动的作业. 它的选项有以下意思:

    #+BEGIN_EXAMPLE
    -l     除了正常信息外, 列出进程ID
    -n     仅显示作业的状态已发生改变的信息, 在它们的状态最后一次通知给用户之后
    -p     仅显示作业进程组的领导者的进程ID
    -r     仅输出运行状态（running）的任务；
    -s     仅输出停止状态（stoped）的任务;
    #+END_EXAMPLE

    如果给定 _jobspec_ , 只输出关于那项作业的信息. 只有遇到不合法选项或者提供了不合法的 _jobspec_ , 返回状态才不为 0 ;

    如果提供了 =-x= 选项, jobs 以对应的进程组ID替换任何一个在 _command_ 或 _args_ 中找到的 _jobspec_ , 并且传递 _args_ 给 _command_ 执行, 返回它的退出状态.

    备注: jobs -x 用法完全看不明白.在后台恢复运行每一个被暂停的作业 _jobsepc_ 的运行, 就好像它被用 =&= 启动了一样.

如果 _jobspec_ 未指定, 将会按shell意见使用最近的作业
** declare/typeset两个命令相同

   #+BEGIN_QUOTE
   declare [-aAfFgilrtux] [-p] [ _name_[= _value_ ] ...]

   typeset [-aAfFgilrtux] [-p] [ _name_[= _value_ ] ...]
   #+END_QUOTE

   声明变量或给他们赋予属性. 如果没有指定 _name_ 那么就显示变量的值.

   *-p* 选项将显示每个 _name_ 的属性和值.
   当使用带有 _name_ 参数的 *-p* 选项时, 其他选项将被忽略.
   当使用不带有 _name_ 参数的 *-p* 选项时, 它将显示所有的,被附加选项指定了属性的,变量的属性和值.[fn:1]
   如果没有其他选项提供给 *-p* , *declare* 将显示所有的shell变量的属性和值.

   *-f* 选项将只限显示shell函数. *-F* 选项禁止显示函数定义; 仅打印函数名和函数属性.
   在使用 *shopt* 时, 如果 *extdebug* 选项是打开的, 定义了函数的源文件的名字和行号也将被显示.
   *-F* 隐含于 *-f* .[fn:2]

   *-g* 选项强制变量在全局作用域被创建或被修改, 即使是在shell函数里执行了 *declare* .

   接下来的选项能够限制输出变量指定的属性或者给变量限定属性:

   - *-a*     每个 _name_ 是一个索引数组变量 (参考上面的数组)
   - *-A*     每个 _name_ 是一个关联数组变量 (参考上面的数组)
   - *-f*     仅使用函数名
   - *-i*     把变量当作整数; 当变量被分配了一个值时, 执行算术求值(参考上方的算术求值);
   - *-l*     当变量被分配一个值, 所有的大写字符串被转换成小写. 大写属性是禁止的;
   - *-r*     使 _name_ 只读. 这些变量名就不能被后面的赋值语句分配值或重置值.
   - *-t*     赋予每一个 _name_ _trace_ 属性. 跟踪函数从调用它的shell中
              继承 *DEBUG* 和 *RETURN* 情境.[fn:3] 跟踪属性对变量而言没有特殊意义.
   - *-u*     当变量被赋予了一个值, 所有的小写字符将被转换成大写. 小写属性是禁止的.
   - *-x*     标记 _name_ 通过环境输出给后面的命令.[fn:4]

   使用'+'替代'-'来关闭属性, 但是以下是例外: +a 未必是用来消毁一个数组变量, +r 不会移除只读属性.

   当在函数中使用时, 每个 _name_ 都是本地的, 与本地命令一样.
   如果一个变量名后被 _=value_ 跟着, 变量的值就被设定为 _value_ .

   除非遇到非法选项, 否则返回值是 0 .
   尝试去定义一个使用"-f foo=bar"的函数;
   尝试去给一个只读变量赋值;
   尝试不使用复合赋值语法(参考上方的数组内容), 去给一个数组变量赋值;
   其中一个 _name_ 不是合法的shell变量名;
   尝试去关闭只读变量的只读状态;
   尝试去关闭一个数组变量的数组状态;
   或者尝试去用 -f 显示一个不存在的函数;
   

** history

   常见用法: 不加任何选项, 直接查看历史命令

   - 技巧

     - 查看各命令被执行的具体时间
       
       #+BEGIN_SRC shell
       # 临时添加, 适合用在公司服务器上
       export HISTTIMEFORMAT="%F %T  "
       #+END_SRC
       要想永久添加, 可以将上面的语句写入 =.bashrc | .bash_profile | /etc/bashrc | /etc/profile= 内

** kill

   #+BEGIN_QUOTE
   kill [-s _sigspec_ | -n _signum_ | - _sigspec_ ] [ _pid_ | _jobspec_ ] ...

   kill -l [ _sigspec_ | _exit-status_ ]
   #+END_QUOTE

   发送指定的sigspec或指定的signum信号给指定的pid的或jobspec进程.
   sigspec 要么是一个大小写敏感的信号名, 比如 *SIGKILL* (前缀SIG带不带都行), 要么是一个信号数;
   signum指的就是信号数.
   如果sigspec未指定, 那么sigspec就被假定是 *SIGTERM* .
   *-l* 的参数列出信号名. 当给定 *-l* 选项时, 如果提供了任意一个参数, 对应参数的信号名将被列出,
   并且返回状态为0.
   *-l* 的exit_status参数要么是一个指定信号数的数字, 要么是被一个信号终结了的进程的退出状态.
   如果至少有一个信号被成功地发送, *kill* 将返回True; 如果发生了错误或遇到了非法选项, 它将返回False

** [[file:set.org][set]]
* Footnotes

[fn:1] 
以下是人话: 如果这个变量在声明时同时指定了值和属性, 就显示出这个变量的值和属性;
如果没有, 就显示变量的值;

[fn:2] The -F option implies -f. 原名是这样的, 我也不会翻了.

[fn:3] 这是原句: Traced  functions inherit the DEBUG and RETURN traps from the calling shell.

[fn:4] 指定的变量会成为环境变量，可供shell以外的程序来使用；

