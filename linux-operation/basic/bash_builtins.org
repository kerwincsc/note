
* BASH内建工具

** bg|fg|jobs

*** bg

    #+BEGIN_QUOTE
    bg [ _jobsepc_ ...]
    #+END_QUOTE

    在后台恢复运行每一个被暂停的作业 _jobsepc_ 的运行, 就好像它被用 =&= 启动了一样.

    如果 _jobspec_ 未指定, 将会按shell意见使用最近的作业.

    bg _jobspec_ 返回零, 除非运行时作业控制是禁止的, 或者运行时作业控制是允许的, 但是被指定的 _jobspec_ 一个都没有找到, 或者没有以作业控制启动.

*** fg

    #+BEGIN_QUOTE
    fg [ _jobspec_ ]
    #+END_QUOTE

    恢复 _jobspec_ 到前台, 并且使它成为当前作业. 如果 _jobspec_ 未指定, 将会按shell意见使用最近的作业.

    返回值有以下几种情况: 

    1. 放到前台执行的命令的返回值;

    2. 将返回失败:

       - 作业控制被关闭时运行;

       - 作业控制被打开时运行, 倘若 _jobspec_ 没有指定一个合法作业或者 _jobsepc_ 指定了一个没有以作业控制启动的作业;

*** jobs

    #+BEGIN_QUOTE
    jobs [-lnprs] [ _jobspec_ ... ]

    jobs -x command [ _args_ ... ]
    #+END_QUOTE

    第一种形式列出了活动的作业. 它的选项有以下意思:

    #+BEGIN_EXAMPLE
    -l     除了正常信息外, 列出进程ID
    -n     仅显示作业的状态已发生改变的信息, 在它们的状态最后一次通知给用户之后
    -p     仅显示作业进程组的领导者的进程ID
    -r     仅输出运行状态（running）的任务；
    -s     仅输出停止状态（stoped）的任务;
    #+END_EXAMPLE

    如果给定 _jobspec_ , 只输出关于那项作业的信息. 只有遇到不合法选项或者提供了不合法的 _jobspec_ , 返回状态才不为 0 ;

    如果提供了 =-x= 选项, jobs 以对应的进程组ID替换任何一个在 _command_ 或 _args_ 中找到的 _jobspec_ , 并且传递 _args_ 给 _command_ 执行, 返回它的退出状态.

    备注: jobs -x 用法完全看不明白.在后台恢复运行每一个被暂停的作业 _jobsepc_ 的运行, 就好像它被用 =&= 启动了一样.

如果 _jobspec_ 未指定, 将会按shell意见使用最近的作业
** declare/typeset两个命令相同

   #+BEGIN_QUOTE
   declare [-aAfFGilrtux] [-p] [ _name_[= _value_ ] ...]
   typeset [-aAfFGilrtux] [-p] [ _name_[= _value_ ] ...]
   #+END_QUOTE

   声明变量或给他们赋予属性. 如果没有指定 _name_ 那么就显示变量的值.

   *-p* 选项将显示每个 _name_ 的属性和值.
   当使用带有 _name_ 参数的 *-p* 选项时, 其他选项将被忽略.
   当使用不带有 _name_ 参数的 *-p* 选项时, 它将显示所有的,被附加选项指定了属性的,变量的属性和值.[fn:1]
   如果没有其他选项提供给 *-p* , *declare* 将显示所有的shell变量的属性和值.

   *-f* 选项将只限显示shell函数. *-F* 选项禁止显示函数定义; 仅打印函数名和函数属性.
   在使用 *shopt* 时, 如果 *extdebug* 选项是打开的, 定义了函数的源文件的名字和行号也将被显示.
   *-F* 隐含于 *-f* .[fn:2]

   *-g* 选项强制变量在全局作用域被创建或被修改, 即使是在shell函数里执行了 *declare* .
   

** history

   常见用法: 不加任何选项, 直接查看历史命令

   - 技巧

     - 查看各命令被执行的具体时间
       
       #+BEGIN_SRC shell
       # 临时添加, 适合用在公司服务器上
       export HISTTIMEFORMAT="%F %T  "
       #+END_SRC
       要想永久添加, 可以将上面的语句写入 =.bashrc | .bash_profile | /etc/bashrc | /etc/profile= 内

** kill

   #+BEGIN_QUOTE
   kill [-s _sigspec_ | -n _signum_ | - _sigspec_ ] [ _pid_ | _jobspec_ ] ...

   kill -l [ _sigspec_ | _exit-status_ ]
   #+END_QUOTE

   发送指定的sigspec或指定的signum信号给指定的pid的或jobspec进程.
   sigspec 要么是一个大小写敏感的信号名, 比如 *SIGKILL* (前缀SIG带不带都行), 要么是一个信号数;
   signum指的就是信号数.
   如果sigspec未指定, 那么sigspec就被假定是 *SIGTERM* .
   *-l* 的参数列出信号名. 当给定 *-l* 选项时, 如果提供了任意一个参数, 对应参数的信号名将被列出,
   并且返回状态为0.
   *-l* 的exit_status参数要么是一个指定信号数的数字, 要么是被一个信号终结了的进程的退出状态.
   如果至少有一个信号被成功地发送, *kill* 将返回True; 如果发生了错误或遇到了非法选项, 它将返回False

* Footnotes

[fn:1] 
以下是人话: 如果这个变量在声明时同时指定了值和属性, 就显示出这个变量的值和属性;
如果没有, 就显示变量的值;

[fn:2] The -F option implies -f. 原名是这样的, 我也不会翻了.

